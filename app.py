import streamlit as st # type: ignore
import cv2 # type: ignore
import numpy as np # type: ignore
from PIL import Image # type: ignore
import io
import sympy as sp # type: ignore
import os
import time
import base64
from io import BytesIO
import matplotlib.pyplot as plt # type: ignore
from app.utils.image_processing import (
    preprocess_image, segment_symbols, create_visualization, 
    merge_touching_symbols, clean_up_after_segmentation
)
from app.utils.recognition import (
    recognize_symbols, recognize_single_symbol, load_model,
    visualize_recognition, load_label_map
)
from app.utils.equation_solver import parse_and_solve_equation

def load_css():
    css_path = os.path.join("app", "static", "css", "style.css")
    if os.path.exists(css_path):
        with open(css_path, "r") as f:
            css = f.read()
            st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)

def get_image_download_link(img, filename="equation_solution.png", text="Download Result"):
    """Generate a download link for an image"""
    buffered = BytesIO()
    img.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode()
    href = f'<a href="data:file/png;base64,{img_str}" download="{filename}">{text}</a>'
    return href

def get_pdf_solution(equation, solution, steps):
    """Create a PDF of the solution using matplotlib (placeholder)"""
    # This is a simplified version; in production, use a proper PDF library
    fig, ax = plt.subplots(figsize=(8, 10))
    ax.axis('off')
    
    # Title
    ax.text(0.5, 0.95, 'MathFi Solution', ha='center', va='top', fontsize=16, fontweight='bold')
    
    # Equation
    ax.text(0.1, 0.85, 'Equation:', fontsize=12, fontweight='bold')
    ax.text(0.1, 0.80, f"${equation}$", fontsize=14)
    
    # Steps
    ax.text(0.1, 0.70, 'Solution Steps:', fontsize=12, fontweight='bold')
    y_pos = 0.65
    for i, step in enumerate(steps):
        ax.text(0.1, y_pos, f"Step {i+1}:", fontsize=10, fontweight='bold')
        ax.text(0.2, y_pos, f"${step}$", fontsize=12)
        y_pos -= 0.05
        
    # Final answer
    ax.text(0.1, y_pos - 0.1, 'Final Answer:', fontsize=12, fontweight='bold')
    ax.text(0.1, y_pos - 0.15, f"${solution}$", fontsize=14)
    
    # Footer
    ax.text(0.5, 0.05, 'Generated by MathFi - Handwritten Math Solver', 
            ha='center', va='bottom', fontsize=8)
    
    buffered = BytesIO()
    plt.savefig(buffered, format='png', dpi=300, bbox_inches='tight')
    plt.close(fig)
    return buffered

def show_beta_notification():
    """Display a beta/work-in-progress notification"""
    beta_html = """
    <div style="
        position: fixed;
        top: 0;
        right: 0;
        margin: 10px;
        padding: 15px;
        background-color: #ff9800;
        color: white;
        border-radius: 5px;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        font-weight: bold;
    ">
        üöß BETA VERSION: This project is still in development üöß
    </div>
    """
    st.markdown(beta_html, unsafe_allow_html=True)
    
    # Also show a more detailed message at the top of the app
    st.warning("""
        ‚ö†Ô∏è **Work in Progress** ‚ö†Ô∏è
        
        This application is currently under active development. Features may be incomplete, 
        and results may not be accurate. We appreciate your patience and feedback as we 
        continue to improve the application.
    """)

def main():
    st.set_page_config(
        page_title="MathFi - Handwritten Math Solver",
        page_icon="üìù",
        layout="centered"
    )
    
    # Load custom CSS
    load_css()
    
    # Beta notification
    beta_html = """
    <div style="
        position: fixed;
        top: 0;
        right: 0;
        margin: 10px;
        padding: 15px;
        background-color: #ff9800;
        color: white;
        border-radius: 5px;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        font-weight: bold;
    ">
        üöß BETA VERSION: This project is still in development üöß
    </div>
    """
    st.markdown(beta_html, unsafe_allow_html=True)
    
    # Work in progress warning
    st.warning("""
        ‚ö†Ô∏è **Work in Progress** ‚ö†Ô∏è
        
        This application is currently under active development. Features may be incomplete, 
        and results may not be accurate. We appreciate your patience and feedback as we 
        continue to improve the application.
    """)
    
    st.markdown("<h1 class='title'>MathFi: Handwritten Math Solver</h1>", unsafe_allow_html=True)
    st.markdown("<p class='subtitle'>Upload an image of a handwritten math equation, and we'll solve it for you!</p>", unsafe_allow_html=True)
    
    # Info box
    st.markdown("""
    <div class='info-box'>
        <strong>Tips for best results:</strong>
        <ul>
            <li>Write clearly and separate symbols</li>
            <li>Use good lighting when taking a photo</li>
            <li>Make sure the equation is well-centered in the image</li>
            <li>Currently supports basic operations (+, -, *, /, =) and variables (x, y)</li>
        </ul>
    </div>
    """, unsafe_allow_html=True)
    
    # Advanced options
    with st.expander("Advanced Options"):
        col1, col2, col3 = st.columns(3)
        with col1:
            use_adaptive_threshold = st.checkbox("Use adaptive thresholding", value=True)
        with col2:
            min_area = st.slider("Minimum symbol area", 50, 500, 100, 10)
        with col3:
            show_visualization = st.checkbox("Show symbol detection", value=True)
        
        # Additional advanced options
        col1, col2 = st.columns(2)
        with col1:
            merge_symbols = st.checkbox("Merge touching symbols", value=True)
        with col2:
            model_type = st.selectbox(
                "Recognition model", 
                options=["Default CNN"],
                index=0
            )
    
    # File uploader
    uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])
    
    # Webcam input
    use_webcam = st.checkbox("Or use webcam")
    if use_webcam:
        img_file_buffer = st.camera_input("Take a picture of your equation")
        if img_file_buffer is not None:
            uploaded_file = img_file_buffer
    
    if uploaded_file is not None:
        # Create a spinner to show loading
        with st.spinner("Processing image..."):
            try:
                # Convert to OpenCV format
                image = Image.open(uploaded_file)
                image = np.array(image)
                
                # Display the original image
                st.markdown("<h2 class='subtitle'>Original Image</h2>", unsafe_allow_html=True)
                st.image(image, channels="BGR", use_column_width=True)
                
                # Preprocess the image
                processed_image = preprocess_image(image, use_adaptive_threshold)
                
                # Display the processed image
                st.markdown("<h2 class='subtitle'>Processed Image</h2>", unsafe_allow_html=True)
                st.image(processed_image, use_column_width=True)
                
                # Segment the symbols
                symbol_images, bounding_boxes = segment_symbols(processed_image, min_area)
                
                # Merge touching symbols if enabled
                if merge_symbols and bounding_boxes:
                    merged_boxes = merge_touching_symbols(bounding_boxes, processed_image.shape)
                    
                    # If merging changed the boxes, re-extract the symbols
                    if len(merged_boxes) != len(bounding_boxes):
                        st.info(f"Merged {len(bounding_boxes) - len(merged_boxes)} touching symbols")
                        
                        # Update the bounding boxes and re-extract symbols
                        bounding_boxes = merged_boxes
                        symbol_images = []
                        
                        for x, y, w, h in bounding_boxes:
                            # Add padding
                            padding = 5
                            x_min = max(0, x - padding)
                            y_min = max(0, y - padding)
                            x_max = min(processed_image.shape[1], x + w + padding)
                            y_max = min(processed_image.shape[0], y + h + padding)
                            
                            # Extract the symbol
                            symbol = processed_image[y_min:y_max, x_min:x_max]
                            
                            # Resize to 28x28 for the model
                            symbol = cv2.resize(symbol, (28, 28), interpolation=cv2.INTER_AREA)
                            symbol_images.append(symbol)
                
                # Clean up the symbols for better recognition
                symbol_images = clean_up_after_segmentation(symbol_images)
                
                if symbol_images:
                    # Load the model once for all processing
                    model = load_model()
                    label_map = load_label_map()
                    
                    # If visualization is enabled, show bounding boxes
                    if show_visualization:
                        # Recognize symbols for visualization
                        symbols_with_confidence = []
                        for i, img in enumerate(symbol_images):
                            symbol, confidence = recognize_single_symbol(img, model)
                            symbols_with_confidence.append((symbol, bounding_boxes[i], confidence))
                        
                        # Create a more informative visualization
                        viz_image = visualize_recognition(image, symbols_with_confidence)
                        
                        # Display the visualization
                        st.markdown("<h2 class='subtitle'>Symbol Detection</h2>", unsafe_allow_html=True)
                        st.image(viz_image, channels="BGR", use_column_width=True)
                    
                    # Recognize the complete expression
                    recognized_expression = recognize_symbols(symbol_images)
                    
                    # Display the recognized expression
                    st.markdown("<h2 class='subtitle'>Recognized Expression</h2>", unsafe_allow_html=True)
                    st.markdown(f"<div class='math-expression'>{recognized_expression}</div>", unsafe_allow_html=True)
                    st.latex(recognized_expression)
                    
                    # Allow manual correction of the expression
                    corrected_expression = st.text_input(
                        "Correct the expression if needed:",
                        value=recognized_expression
                    )
                    
                    # Use the corrected expression for solving
                    expression_to_solve = corrected_expression
                    
                    # Solve the equation
                    try:
                        solution, steps = parse_and_solve_equation(expression_to_solve)
                        
                        # Display the solution
                        st.markdown("<h2 class='subtitle'>Solution</h2>", unsafe_allow_html=True)
                        st.markdown("<div class='solution-box'>", unsafe_allow_html=True)
                        
                        for i, step in enumerate(steps):
                            st.markdown(f"<div class='step-box'>Step {i+1}:</div>", unsafe_allow_html=True)
                            st.latex(step)
                        
                        st.markdown("</div>", unsafe_allow_html=True)
                        st.success(f"Final Answer: {solution}")
                        
                        # Generate solution PDF
                        pdf_buffer = get_pdf_solution(expression_to_solve, solution, steps)
                        
                        # Download buttons
                        col1, col2 = st.columns(2)
                        with col1:
                            st.download_button(
                                label="Download Solution as PDF",
                                data=pdf_buffer,
                                file_name="mathfi_solution.pdf",
                                mime="application/pdf",
                            )
                        
                        with col2:
                            # Convert the visualization to PIL Image for download
                            if 'viz_image' in locals():
                                pil_image = Image.fromarray(cv2.cvtColor(viz_image, cv2.COLOR_BGR2RGB))
                                buffer = BytesIO()
                                pil_image.save(buffer, format="PNG")
                                st.download_button(
                                    label="Download Visualization",
                                    data=buffer.getvalue(),
                                    file_name="mathfi_visualization.png",
                                    mime="image/png",
                                )
                        
                    except Exception as e:
                        st.markdown("<div class='error-box'>", unsafe_allow_html=True)
                        st.error(f"Error solving the equation: {str(e)}")
                        
                        # Provide tips based on the error
                        if "parsing" in str(e).lower():
                            st.info("Tip: Check if the equation was correctly recognized. Some symbols might be misread.")
                        elif "InvalidOperation" in str(e) or "ZeroDivisionError" in str(e):
                            st.info("Tip: The equation might involve division by zero or an invalid operation.")
                        
                        st.markdown("</div>", unsafe_allow_html=True)
                        
                        # Report a misread option
                        if st.button("Report a Misread"):
                            st.session_state.reported = True
                            st.info("Thanks for reporting! Your feedback helps us improve.")
                else:
                    st.warning("No symbols detected. Try another image or adjust the minimum symbol area.")
            except Exception as e:
                st.error(f"Error processing the image: {str(e)}")
                import traceback
                st.text(traceback.format_exc())
    
    # Footer
    st.markdown("""
    <div class='footer'>
        MathFi - An open-source handwritten math solver<br>
        Built with Streamlit, OpenCV, TensorFlow, and SymPy
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main() 